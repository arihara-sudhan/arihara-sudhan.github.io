SOURCE: Cormen, Leiserson, Rivest, and Stein's Introduction to Algorithms; La Rocca's Advanced Algorithms and Data Structures; Goodrich, Tamassia, and Mount's Data Structures and Algorithms in C++; Weiss's Data Structures and Algorithm Analysis in C++; Drozdek's Data Structures and Algorithms in C++

1. C++ is a general-purpose programming language that supports both procedural and object-oriented programming. It’s widely used for system software, games, embedded systems, and high-performance applications.
2. Key Concepts
	Variables: Store data (int, float, char, etc.)
	Operators: Arithmetic (+, -, *, /), relational (==, !=), logical (&&, ||)
	Control Structures: if, for, while, switch
	Functions: Reusable blocks of code
	Input/Output: cin and cout for console interaction
Example:
	#include <iostream>
	using namespace std;
	int main() {
	    int age = 25;
	    if (age > 18) {
	        cout << "Adult" << endl;
	    }
	    return 0;
	}
3. C++ Snippets
	1. Classes & Objects
	Class: A blueprint for objects.
	Object: An instance of a class.
	#include <iostream>
	using namespace std;
	class Car {
	public:
	    string brand;
	    int year;

	    void display() {
	        cout << brand << " - " << year << endl;
	    }
	};
	int main() {
	    Car myCar;         // Object creation
	    myCar.brand = "Toyota";
	    myCar.year = 2020;
	    myCar.display();   // Output: Toyota - 2020
	}

	2. Encapsulation
	Keep data private and provide public methods to access or modify it.
	#include <iostream>
	using namespace std;
	class BankAccount {
	private:
	    double balance;
	public:
	    void deposit(double amount) {
	        if(amount > 0) balance += amount;
	    }
	    double getBalance() {
	        return balance;
	    }
	};
	int main() {
	    BankAccount account;
	    account.deposit(500);
	    cout << "Balance: " << account.getBalance() << endl; // Output: Balance: 500
	}

	3. Inheritance
	Child class inherits properties & methods from a parent class.
	#include <iostream>
	using namespace std;
	class Vehicle {
	public:
	    void start() { cout << "Vehicle started" << endl; }
	};
	class Car : public Vehicle {
	public:
	    void honk() { cout << "Car honks" << endl; }
	};
	int main() {
	    Car myCar;
	    myCar.start(); // Inherited method
	    myCar.honk();  // Own method
	}

	4. Polymorphism
	Compile-time polymorphism: Function overloading
	Runtime polymorphism: Virtual functions
	Runtime Example:
	#include <iostream>
	using namespace std;
	class Animal {
	public:
	    virtual void speak() {
	        cout << "Animal sound" << endl;
	    }
	};
	class Dog : public Animal {
	public:
	    void speak() override {
	        cout << "Bark" << endl;
	    }
	};
	int main() {
	    Animal* a = new Dog();
	    a->speak(); // Output: Bark
	    delete a;
	}

	5. Templates
	Allow writing generic functions or classes.
	#include <iostream>
	using namespace std;
	template <typename T>
	T add(T a, T b) {
	    return a + b;
	}
	int main() {
	    cout << add<int>(5, 3) << endl;      // 8
	    cout << add<double>(5.5, 3.2) << endl; // 8.7
	}

	6. Pointers
	Store memory addresses and allow dynamic memory management.
	#include <iostream>
	using namespace std;
	int main() {
	    int x = 10;
	    int* ptr = &x;   // Pointer stores address
	    cout << *ptr << endl; // Dereference -> Output: 10

	    // Dynamic allocation
	    int* y = new int;
	    *y = 20;
	    cout << *y << endl; // Output: 20
	    delete y;           // Free memory
	}
4. C++ in a nutshell
	Memory Types: 
		Stack vs Heap
		Stack = auto memory, Heap = dynamic memory
	Dynamic Allocation
		new / delete
	Pointers
		Store memory addresses, used with dynamic memory
		Smart Pointers	Automatic memory management (unique_ptr, shared_ptr)
	STL Containers
		vector, list, map, set, etc.
	STL Iterators
		Traverse containers like pointers
	STL Algorithms
		sort, find, accumulate, max_element, etc.
	Functors
		Objects behaving like functions
5. Recursion: Recursion is when a function calls itself to solve a smaller instance of the same problem
	returnType functionName(parameters) {
	    if(base_condition) return value; // stopping condition
	    else return functionName(smaller_problem);
	}
6. Recursion Types
	1. Tail Recursion: In tail recursion, the recursive call is the last operation in the function. No further computation happens after the recursive call. Compiler can optimize tail recursion to avoid extra stack usage.
	Example – factorial (tail recursive):
	#include <iostream>
	using namespace std;
	int factorialHelper(int n, int result) {
	    if (n == 0) return result;
	    return factorialHelper(n - 1, n * result); // tail recursion
	}
	int factorial(int n) {
	    return factorialHelper(n, 1);
	}
	int main() {
	    cout << factorial(5) << endl; // Output: 120
	}
	Here, the recursive call factorialHelper(n - 1, n * result) is the last operation.

	2. Non-Tail Recursion: In non-tail recursion, additional work is done after the recursive call. Each call must stay on the stack until the recursion finishes.
	Example – factorial (non-tail recursive):
	#include <iostream>
	using namespace std;
	int factorial(int n) {
	    if(n == 0) return 1;
	    return n * factorial(n - 1); // non-tail recursion
	}
	int main() {
	    cout << factorial(5) << endl; // Output: 120
	}
	Here, after factorial(n - 1) returns, we still multiply by n. So it’s non-tail recursion.

	3. Indirect Recursion: Indirect recursion occurs when function A calls B, and B calls A (possibly through other functions).
	It can involve multiple functions.
	Example:
	#include <iostream>
	using namespace std;

	void functionB(int n);

	void functionA(int n) {
	    if(n <= 0) return;
	    cout << "A: " << n << endl;
	    functionB(n - 1); // A calls B
	}

	void functionB(int n) {
	    if(n <= 0) return;
	    cout << "B: " << n << endl;
	    functionA(n / 2); // B calls A
	}

	int main() {
	    functionA(10);
	}
7. Backtracking is a problem-solving technique where you build a solution step by step, and abandon a solution as soon as you realize it cannot lead to a valid solution. Think of it as “trial and error” with smart pruning.
	Example: N-Queens Problem
8. Complexity measures how efficient an algorithm is in terms of:
	Time complexity – How much time it takes to run.
	Space complexity – How much memory it uses.
9. Asymptotic Analysis: Asymptotic analysis describes algorithm efficiency for large inputs. We focus on the dominant factor and ignore constants and smaller terms.
	for(int i=0; i<n; i++)        // O(n)
	    for(int j=0; j<n; j++)    // O(n)
	        cout << i+j << endl;  // total O(n^2)
	Big-O (O) – Worst Case: UPPER BOUND
		Definition: Maximum steps an algorithm takes.
		Linear Search: Worst case occurs when key is not present or last element.
		Example:
		Array: [5, 2, 9, 1, 7], key = 10
		Steps: check 5 → check 2 → check 9 → check 1 → check 7 → not found
		Total steps = n
		So, Big-O = O(n)
	Big-Omega (Ω) – Best Case: LOWER BOUND
		Definition: Minimum steps an algorithm takes.
		Linear Search: Best case occurs when key is the first element.
		Example:
		Array: [5, 2, 9, 1, 7], key = 5
		Steps: check 5 → found
		Total steps = 1
		So, Big-Omega = Ω(1)
	Big-Theta (Θ) - Average Case: TIGHT BOUND
		Definition: When upper and lower bounds are the same, gives exact growth rate.
		Linear Search Average Case: Key is somewhere in the middle (or random), expected n/2 steps.
		Asymptotic notation ignores constants → Θ(n)
10. Indicator random variables: An indicator random variable is a simple variable that tells us whether an event happens.
	IA = {
	    1   if event A occurs
	    0   if event A does not occur
	}
	It is used to count occurrences or to simplify expected value calculations.
	Example: Count number of heads when flipping a fair coin 3 times.
	Coin flips: H T H
	Let X = number of heads.
	Define indicator variables:
	I1 = 1 if first flip = H, else 0 → 1
	I2 = 1 if second flip = H, else 0 → 0
	I3 = 1 if third flip = H, else 0 → 1
	Total heads:
	X = I1 + I2 + I3 = 1 + 0 + 1 = 2
	Why useful: Makes expected value easy.
	E[X] = E[I1 + I2 + I3]
	     = E[I1] + E[I2] + E[I3]
	For a fair coin, E[Ii] = 0.5
	So, E[X] = 1.5

11. Probabilistic Analysis: We analyze algorithms on average over random input. Useful when worst-case analysis is too pessimistic.
Linear Search: Expected Comparisons
	Step 1: Cost if key is at position i
	- If key is at position 1 → 1 comparison
	- If key is at position 2 → 2 comparisons
	- ...
	- If key is at position n → n comparisons
	Step 2: Probability
	- Key is equally likely at any position
	- P(key at i) = 1/n
	Step 3: Expected Value
	E[comparisons] = sum( cost(i) * P(i) )
	               = sum( i * (1/n) ) for i = 1 to n
	Step 4: Simplify
	E[comparisons] = (1/n) * (1 + 2 + 3 + ... + n)
	                = (1/n) * (n(n+1)/2)
	                = (n+1)/2
On average, linear search needs about n/2 comparisons.
12. Randomized Algorithms: Algorithms that use random choices to get good average performance. Randomization helps avoid worst-case inputs.
	Example 1: Randomized QuickSort
	- Pick a random pivot
	- Avoids worst-case O(n^2) on sorted input
	- Expected runtime = O(n log n)
	Example 2: Randomized Min
	- Randomly pick elements until minimum is found
	- Randomization makes average-time analysis easier
13. Advanced Arrays
- Sparse Arrays: A sparse array is an array where most elements are zero (or a default value). Instead of storing all elements, we store only the non-zero elements to save memory.
#include <iostream>
#include <map>
using namespace std;
int main() {
    int n = 5;
    // Sparse array: store only non-zero elements using map
    map<int, int> sparseArray;
    sparseArray[0] = 10; // index 0 has 10
    sparseArray[3] = 5;  // index 3 has 5

    // Access elements
    for(int i = 0; i < n; i++) {
        if(sparseArray.count(i))
            cout << sparseArray[i] << " ";
        else
            cout << 0 << " "; // default 0
    }
}
Output:
10 0 0 5 0
Saves memory for mostly-zero arrays.
- Dynamic Arrays: A dynamic array can change its size at runtime.
Example: vector in C++ | It grows automatically when more elements are added.
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> dynamicArray;

    // Add elements
    dynamicArray.push_back(10);
    dynamicArray.push_back(20);
    dynamicArray.push_back(30);

    // Access elements
    for(int i : dynamicArray) cout << i << " ";
}
Output:
10 20 30
Unlike static arrays, no need to predefine size.

14. How Cache Works
CPU cache stores blocks of consecutive memory called cache lines.
Suppose:
	Cache line size = 4 integers
	Memory: [a0, a1, a2, a3, a4, a5, a6, a7, ...]
	When CPU accesses a0, the entire cache line [a0, a1, a2, a3] is loaded into cache.
	Next access:
	a1 → already in cache → cache hit
	a4 → not in this cache line → cache miss → CPU loads [a4, a5, a6, a7]
	Sequential access = most next elements are already in cache → fast
	❌ Random access = next element likely not in current cache line → slow

15. Cache-Aware Structures | Access memory in the order it is stored
	Example 1: Row-Major 2D Array (Cache-Friendly)
	In C++, 2D arrays are stored row by row (row-major order).
	#include <iostream>
	using namespace std;

	int main() {
	    int n = 3, m = 3;
	    int arr[3][3] = {{1,2,3},{4,5,6},{7,8,9}};

	    cout << "Row-wise traversal (cache-friendly): ";
	    for(int i=0;i<n;i++) {
	        for(int j=0;j<m;j++) {
	            cout << arr[i][j] << " ";
	        }
	    }
	}

	Example 2: Blocking / Tiling for Large Matrices
	For large matrices, accessing sequentially within blocks improves cache usage.
	#include <iostream>
	using namespace std;

	int main() {
	    const int N = 4;
	    int A[N][N] = {{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};

	    int blockSize = 2;

	    cout << "Block-wise traversal:" << endl;
	    for(int i=0; i<N; i+=blockSize) {
	        for(int j=0; j<N; j+=blockSize) {
	            // Traverse each block
	            for(int ii=i; ii<i+blockSize; ii++) {
	                for(int jj=j; jj<j+blockSize; jj++) {
	                    cout << A[ii][jj] << " ";
	                }
	            }
	        }
	    }
	}
	Idea: Load small blocks of matrix into cache, iterate fully, then move to next block.
	Reduces cache misses for large matrices → faster than naïve traversal.
	Example 3: Structure of Arrays (SoA) vs Array of Structures (AoS)
	AoS (slower for cache)
	- struct Point { int x, y; };
	- Point arr[1000];
	- Each element = {x, y}
	- Accessing all x values → CPU jumps → cache misses

	SoA (cache-friendly)
	- int x[1000], y[1000];
	- All x values stored sequentially → accessing them → cache hits
	- Faster iteration
16. Linked List Implementation
	1. Singly Linked List: Each node has data + pointer to next node. Traversal is only forward.
	#include <iostream>
	using namespace std;
	struct Node {
	    int data;
	    Node* next;
	    Node(int val) : data(val), next(nullptr) {}
	};
	int main() {
	    // Create nodes
	    Node* head = new Node(10);
	    head->next = new Node(20);
	    head->next->next = new Node(30);
	    // Traverse
	    Node* temp = head;
	    while(temp) {
	        cout << temp->data << " ";
	        temp = temp->next;
	    }
	}
	Output:
	10 20 30

	2. Doubly Linked List: Each node has data + pointer to next + pointer to previous. Traversal forward or backward.
	#include <iostream>
	using namespace std;

	struct Node {
	    int data;
	    Node* next;
	    Node* prev;
	    Node(int val) : data(val), next(nullptr), prev(nullptr) {}
	};

	int main() {
	    Node* head = new Node(10);
	    Node* second = new Node(20);
	    Node* third = new Node(30);

	    head->next = second;
	    second->prev = head;
	    second->next = third;
	    third->prev = second;

	    // Forward traversal
	    Node* temp = head;
	    while(temp) {
	        cout << temp->data << " ";
	        temp = temp->next;
	    }
	}
	Output:
	10 20 30

	3. Circular Linked List: Last node points back to head, forming a circle. Can be singly or doubly circular.
	#include <iostream>
	using namespace std;

	struct Node {
	    int data;
	    Node* next;
	    Node(int val) : data(val), next(nullptr) {}
	};

	int main() {
	    Node* head = new Node(10);
	    Node* second = new Node(20);
	    Node* third = new Node(30);

	    head->next = second;
	    second->next = third;
	    third->next = head; // circular

	    // Traverse circular list (stop after one loop)
	    Node* temp = head;
	    int count = 0;
	    do {
	        cout << temp->data << " ";
	        temp = temp->next;
	        count++;
	    } while(temp != head && count < 10); // prevent infinite loop
	}
	Output:
	10 20 30
